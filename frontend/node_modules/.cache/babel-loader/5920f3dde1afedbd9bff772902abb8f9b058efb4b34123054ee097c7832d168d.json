{"ast":null,"code":"'use client';\n\nimport { useState, useCallback } from 'react';\nimport { useFloating, autoUpdate, useDelayGroup, useInteractions, useHover, useFocus, useRole, useDismiss, offset, shift, flip, arrow, inline } from '@floating-ui/react';\nimport { useId, useDidUpdate } from '@mantine/hooks';\nimport { useTooltipGroupContext } from './TooltipGroup/TooltipGroup.context.mjs';\nfunction getDefaultMiddlewares(middlewares) {\n  if (middlewares === void 0) {\n    return {\n      shift: true,\n      flip: true\n    };\n  }\n  const result = {\n    ...middlewares\n  };\n  if (middlewares.shift === void 0) {\n    result.shift = true;\n  }\n  if (middlewares.flip === void 0) {\n    result.flip = true;\n  }\n  return result;\n}\nfunction getTooltipMiddlewares(settings) {\n  const middlewaresOptions = getDefaultMiddlewares(settings.middlewares);\n  const middlewares = [offset(settings.offset)];\n  if (middlewaresOptions.shift) {\n    middlewares.push(shift(typeof middlewaresOptions.shift === \"boolean\" ? {\n      padding: 8\n    } : {\n      padding: 8,\n      ...middlewaresOptions.shift\n    }));\n  }\n  if (middlewaresOptions.flip) {\n    middlewares.push(typeof middlewaresOptions.flip === \"boolean\" ? flip() : flip(middlewaresOptions.flip));\n  }\n  middlewares.push(arrow({\n    element: settings.arrowRef,\n    padding: settings.arrowOffset\n  }));\n  if (middlewaresOptions.inline) {\n    middlewares.push(typeof middlewaresOptions.inline === \"boolean\" ? inline() : inline(middlewaresOptions.inline));\n  } else if (settings.inline) {\n    middlewares.push(inline());\n  }\n  return middlewares;\n}\nfunction useTooltip(settings) {\n  const [uncontrolledOpened, setUncontrolledOpened] = useState(settings.defaultOpened);\n  const controlled = typeof settings.opened === \"boolean\";\n  const opened = controlled ? settings.opened : uncontrolledOpened;\n  const withinGroup = useTooltipGroupContext();\n  const uid = useId();\n  const onChange = useCallback(_opened => {\n    setUncontrolledOpened(_opened);\n    if (_opened) {\n      setCurrentId(uid);\n    }\n  }, [uid]);\n  const {\n    x,\n    y,\n    context,\n    refs,\n    placement,\n    middlewareData: {\n      arrow: {\n        x: arrowX,\n        y: arrowY\n      } = {}\n    }\n  } = useFloating({\n    strategy: settings.strategy,\n    placement: settings.position,\n    open: opened,\n    onOpenChange: onChange,\n    middleware: getTooltipMiddlewares(settings),\n    whileElementsMounted: autoUpdate\n  });\n  const {\n    delay: groupDelay,\n    currentId,\n    setCurrentId\n  } = useDelayGroup(context, {\n    id: uid\n  });\n  const {\n    getReferenceProps,\n    getFloatingProps\n  } = useInteractions([useHover(context, {\n    enabled: settings.events?.hover,\n    delay: withinGroup ? groupDelay : {\n      open: settings.openDelay,\n      close: settings.closeDelay\n    },\n    mouseOnly: !settings.events?.touch\n  }), useFocus(context, {\n    enabled: settings.events?.focus,\n    visibleOnly: true\n  }), useRole(context, {\n    role: \"tooltip\"\n  }),\n  // Cannot be used with controlled tooltip, page jumps\n  useDismiss(context, {\n    enabled: typeof settings.opened === \"undefined\"\n  })]);\n  useDidUpdate(() => {\n    settings.onPositionChange?.(placement);\n  }, [placement]);\n  const isGroupPhase = opened && currentId && currentId !== uid;\n  return {\n    x,\n    y,\n    arrowX,\n    arrowY,\n    reference: refs.setReference,\n    floating: refs.setFloating,\n    getFloatingProps,\n    getReferenceProps,\n    isGroupPhase,\n    opened,\n    placement\n  };\n}\nexport { useTooltip };","map":{"version":3,"names":["getDefaultMiddlewares","middlewares","shift","flip","result","getTooltipMiddlewares","settings","middlewaresOptions","offset","push","padding","arrow","element","arrowRef","arrowOffset","inline","useTooltip","uncontrolledOpened","setUncontrolledOpened","useState","defaultOpened","controlled","opened","withinGroup","useTooltipGroupContext","uid","useId","onChange","useCallback","_opened","setCurrentId","x","y","context","refs","placement","middlewareData","arrowX","arrowY","useFloating","strategy","position","open","onOpenChange","middleware","whileElementsMounted","autoUpdate","delay","groupDelay","currentId","useDelayGroup","id","getReferenceProps","getFloatingProps","useInteractions","useHover","enabled","events","hover","openDelay","close","closeDelay","mouseOnly","touch","useFocus","focus","visibleOnly","useRole","role","useDismiss","useDidUpdate","onPositionChange","isGroupPhase","reference","setReference","floating","setFloating"],"sources":["C:\\IVOSIS\\IvosisProjectManagement\\frontend\\node_modules\\@mantine\\core\\src\\components\\Tooltip\\use-tooltip.ts"],"sourcesContent":["import { useCallback, useState } from 'react';\nimport {\n  arrow,\n  autoUpdate,\n  flip,\n  inline,\n  offset,\n  shift,\n  useDelayGroup,\n  useDismiss,\n  useFloating,\n  useFocus,\n  useHover,\n  useInteractions,\n  useRole,\n  type Middleware,\n} from '@floating-ui/react';\nimport { useDidUpdate, useId } from '@mantine/hooks';\nimport { FloatingAxesOffsets, FloatingPosition, FloatingStrategy } from '../Floating';\nimport { type TooltipMiddlewares } from './Tooltip.types';\nimport { useTooltipGroupContext } from './TooltipGroup/TooltipGroup.context';\n\ninterface UseTooltip {\n  position: FloatingPosition;\n  closeDelay?: number;\n  openDelay?: number;\n  onPositionChange?: (position: FloatingPosition) => void;\n  opened?: boolean;\n  defaultOpened?: boolean;\n  offset: number | FloatingAxesOffsets;\n  arrowRef?: React.RefObject<HTMLDivElement | null>;\n  arrowOffset?: number;\n  events?: { hover: boolean; focus: boolean; touch: boolean };\n  positionDependencies: any[];\n  inline?: boolean;\n  strategy?: FloatingStrategy;\n  middlewares?: TooltipMiddlewares;\n}\n\nfunction getDefaultMiddlewares(middlewares: TooltipMiddlewares | undefined): TooltipMiddlewares {\n  if (middlewares === undefined) {\n    return { shift: true, flip: true };\n  }\n\n  const result = { ...middlewares };\n  if (middlewares.shift === undefined) {\n    result.shift = true;\n  }\n\n  if (middlewares.flip === undefined) {\n    result.flip = true;\n  }\n\n  return result;\n}\n\nfunction getTooltipMiddlewares(settings: UseTooltip) {\n  const middlewaresOptions = getDefaultMiddlewares(settings.middlewares);\n  const middlewares: Middleware[] = [offset(settings.offset)];\n\n  if (middlewaresOptions.shift) {\n    middlewares.push(\n      shift(\n        typeof middlewaresOptions.shift === 'boolean'\n          ? { padding: 8 }\n          : { padding: 8, ...middlewaresOptions.shift }\n      )\n    );\n  }\n\n  if (middlewaresOptions.flip) {\n    middlewares.push(\n      typeof middlewaresOptions.flip === 'boolean' ? flip() : flip(middlewaresOptions.flip)\n    );\n  }\n\n  middlewares.push(arrow({ element: settings.arrowRef!, padding: settings.arrowOffset }));\n\n  if (middlewaresOptions.inline) {\n    middlewares.push(\n      typeof middlewaresOptions.inline === 'boolean' ? inline() : inline(middlewaresOptions.inline)\n    );\n  } else if (settings.inline) {\n    middlewares.push(inline());\n  }\n\n  return middlewares;\n}\n\nexport function useTooltip(settings: UseTooltip) {\n  const [uncontrolledOpened, setUncontrolledOpened] = useState(settings.defaultOpened);\n  const controlled = typeof settings.opened === 'boolean';\n  const opened = controlled ? settings.opened : uncontrolledOpened;\n  const withinGroup = useTooltipGroupContext();\n  const uid = useId();\n\n  const onChange = useCallback(\n    (_opened: boolean) => {\n      setUncontrolledOpened(_opened);\n\n      if (_opened) {\n        setCurrentId(uid);\n      }\n    },\n    [uid]\n  );\n\n  const {\n    x,\n    y,\n    context,\n    refs,\n    placement,\n    middlewareData: { arrow: { x: arrowX, y: arrowY } = {} },\n  } = useFloating({\n    strategy: settings.strategy,\n    placement: settings.position,\n    open: opened,\n    onOpenChange: onChange,\n    middleware: getTooltipMiddlewares(settings),\n    whileElementsMounted: autoUpdate,\n  });\n\n  const { delay: groupDelay, currentId, setCurrentId } = useDelayGroup(context, { id: uid });\n\n  const { getReferenceProps, getFloatingProps } = useInteractions([\n    useHover(context, {\n      enabled: settings.events?.hover,\n      delay: withinGroup ? groupDelay : { open: settings.openDelay, close: settings.closeDelay },\n      mouseOnly: !settings.events?.touch,\n    }),\n    useFocus(context, { enabled: settings.events?.focus, visibleOnly: true }),\n    useRole(context, { role: 'tooltip' }),\n    // Cannot be used with controlled tooltip, page jumps\n    useDismiss(context, { enabled: typeof settings.opened === 'undefined' }),\n  ]);\n\n  useDidUpdate(() => {\n    settings.onPositionChange?.(placement);\n  }, [placement]);\n\n  const isGroupPhase = opened && currentId && currentId !== uid;\n\n  return {\n    x,\n    y,\n    arrowX,\n    arrowY,\n    reference: refs.setReference,\n    floating: refs.setFloating,\n    getFloatingProps,\n    getReferenceProps,\n    isGroupPhase,\n    opened,\n    placement,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}