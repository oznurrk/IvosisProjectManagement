{"ast":null,"code":"'use client';\n\nimport { useRef, useMemo, useEffect } from 'react';\nimport { useCallbackRef } from '../utils/use-callback-ref/use-callback-ref.mjs';\nfunction useDebouncedCallback(callback, options) {\n  const {\n    delay,\n    flushOnUnmount,\n    leading\n  } = typeof options === \"number\" ? {\n    delay: options,\n    flushOnUnmount: false,\n    leading: false\n  } : options;\n  const handleCallback = useCallbackRef(callback);\n  const debounceTimerRef = useRef(0);\n  const lastCallback = useMemo(() => {\n    const currentCallback = Object.assign((...args) => {\n      window.clearTimeout(debounceTimerRef.current);\n      const isFirstCall = currentCallback._isFirstCall;\n      currentCallback._isFirstCall = false;\n      if (leading && isFirstCall) {\n        handleCallback(...args);\n        return;\n      }\n      function clearTimeoutAndLeadingRef() {\n        window.clearTimeout(debounceTimerRef.current);\n        debounceTimerRef.current = 0;\n        currentCallback._isFirstCall = true;\n      }\n      const flush = () => {\n        if (debounceTimerRef.current !== 0) {\n          clearTimeoutAndLeadingRef();\n          handleCallback(...args);\n        }\n      };\n      const cancel = () => {\n        clearTimeoutAndLeadingRef();\n      };\n      currentCallback.flush = flush;\n      currentCallback.cancel = cancel;\n      debounceTimerRef.current = window.setTimeout(flush, delay);\n    }, {\n      flush: () => {},\n      cancel: () => {},\n      _isFirstCall: true\n    });\n    return currentCallback;\n  }, [handleCallback, delay, leading]);\n  useEffect(() => () => {\n    if (flushOnUnmount) {\n      lastCallback.flush();\n    } else {\n      lastCallback.cancel();\n    }\n  }, [lastCallback, flushOnUnmount]);\n  return lastCallback;\n}\nexport { useDebouncedCallback };","map":{"version":3,"names":["useDebouncedCallback","callback","options","delay","flushOnUnmount","leading","handleCallback","useCallbackRef","debounceTimerRef","useRef","lastCallback","useMemo","currentCallback","Object","assign","args","window","clearTimeout","current","isFirstCall","_isFirstCall","clearTimeoutAndLeadingRef","flush","cancel","setTimeout","useEffect"],"sources":["C:\\Users\\Asus\\Desktop\\Ivosis\\IvosisProjectManagement\\frontend\\node_modules\\@mantine\\hooks\\src\\use-debounced-callback\\use-debounced-callback.ts"],"sourcesContent":["import { useEffect, useMemo, useRef } from 'react';\nimport { useCallbackRef } from '../utils';\n\nexport interface UseDebouncedCallbackOptions {\n  delay: number;\n  flushOnUnmount?: boolean;\n  leading?: boolean;\n}\n\nexport type UseDebouncedCallbackReturnValue<T extends (...args: any[]) => any> = ((\n  ...args: Parameters<T>\n) => void) & { flush: () => void; cancel: () => void };\n\nexport function useDebouncedCallback<T extends (...args: any[]) => any>(\n  callback: T,\n  options: number | UseDebouncedCallbackOptions\n) {\n  const { delay, flushOnUnmount, leading } =\n    typeof options === 'number'\n      ? { delay: options, flushOnUnmount: false, leading: false }\n      : options;\n\n  const handleCallback = useCallbackRef(callback);\n  const debounceTimerRef = useRef(0);\n\n  const lastCallback = useMemo(() => {\n    const currentCallback = Object.assign(\n      (...args: Parameters<T>) => {\n        window.clearTimeout(debounceTimerRef.current);\n\n        const isFirstCall = currentCallback._isFirstCall;\n        currentCallback._isFirstCall = false;\n\n        if (leading && isFirstCall) {\n          handleCallback(...args);\n          return;\n        }\n\n        function clearTimeoutAndLeadingRef() {\n          window.clearTimeout(debounceTimerRef.current);\n          debounceTimerRef.current = 0;\n          currentCallback._isFirstCall = true;\n        }\n\n        const flush = () => {\n          if (debounceTimerRef.current !== 0) {\n            clearTimeoutAndLeadingRef();\n            handleCallback(...args);\n          }\n        };\n\n        const cancel = () => {\n          clearTimeoutAndLeadingRef();\n        };\n\n        currentCallback.flush = flush;\n        currentCallback.cancel = cancel;\n        debounceTimerRef.current = window.setTimeout(flush, delay);\n      },\n      { flush: () => {}, cancel: () => {}, _isFirstCall: true }\n    );\n    return currentCallback;\n  }, [handleCallback, delay, leading]);\n\n  useEffect(\n    () => () => {\n      if (flushOnUnmount) {\n        lastCallback.flush();\n      } else {\n        lastCallback.cancel();\n      }\n    },\n    [lastCallback, flushOnUnmount]\n  );\n\n  return lastCallback;\n}\n"],"mappings":";;;;AAagB,SAAAA,qBACdC,QAAA,EACAC,OACA;EACA,MAAM;IAAEC,KAAA;IAAOC,cAAgB;IAAAC;EAAA,IAC7B,OAAOH,OAAA,KAAY,QACf;IAAEC,KAAA,EAAOD,OAAS;IAAAE,cAAA,EAAgB,KAAO;IAAAC,OAAA,EAAS;EAClD,IAAAH,OAAA;EAEA,MAAAI,cAAA,GAAiBC,cAAA,CAAeN,QAAQ;EACxC,MAAAO,gBAAA,GAAmBC,MAAA,CAAO,CAAC;EAE3B,MAAAC,YAAA,GAAeC,OAAA,CAAQ,MAAM;IACjC,MAAMC,eAAA,GAAkBC,MAAO,CAAAC,MAAA,CAC7B,IAAIC,IAAwB;MACnBC,MAAA,CAAAC,YAAA,CAAaT,gBAAA,CAAiBU,OAAO;MAE5C,MAAMC,WAAA,GAAcP,eAAgB,CAAAQ,YAAA;MACpCR,eAAA,CAAgBQ,YAAe;MAE/B,IAAIf,OAAA,IAAWc,WAAa;QAC1Bb,cAAA,CAAe,GAAGS,IAAI;QACtB;MAAA;MAGF,SAASM,yBAA4BA,CAAA;QAC5BL,MAAA,CAAAC,YAAA,CAAaT,gBAAA,CAAiBU,OAAO;QAC5CV,gBAAA,CAAiBU,OAAU;QAC3BN,eAAA,CAAgBQ,YAAe;MAAA;MAGjC,MAAME,KAAA,GAAQA,CAAA,KAAM;QACd,IAAAd,gBAAA,CAAiBU,OAAA,KAAY,CAAG;UACRG,yBAAA;UAC1Bf,cAAA,CAAe,GAAGS,IAAI;QAAA;MAE1B;MAEA,MAAMQ,MAAA,GAASA,CAAA,KAAM;QACOF,yBAAA;MAC5B;MAEAT,eAAA,CAAgBU,KAAQ,GAAAA,KAAA;MACxBV,eAAA,CAAgBW,MAAS,GAAAA,MAAA;MACzBf,gBAAA,CAAiBU,OAAU,GAAAF,MAAA,CAAOQ,UAAW,CAAAF,KAAA,EAAOnB,KAAK;IAC3D,GACA;MAAEmB,KAAA,EAAOA,CAAA,KAAM,CAAC;MAAGC,MAAA,EAAQA,CAAA,KAAM,CAAC;MAAGH,YAAA,EAAc;IAAK,CAC1D;IACO,OAAAR,eAAA;EACN,IAACN,cAAgB,EAAAH,KAAA,EAAOE,OAAO,CAAC;EAEnCoB,SAAA,CACE,MAAM,MAAM;IACV,IAAIrB,cAAgB;MAClBM,YAAA,CAAaY,KAAM;IAAA,CACd;MACLZ,YAAA,CAAaa,MAAO;IAAA;EAExB,GACA,CAACb,YAAA,EAAcN,cAAc,CAC/B;EAEO,OAAAM,YAAA;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}