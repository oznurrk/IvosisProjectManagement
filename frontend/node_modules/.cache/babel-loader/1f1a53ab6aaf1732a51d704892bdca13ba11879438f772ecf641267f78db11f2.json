{"ast":null,"code":"'use client';\n\nimport { useRef, useCallback, useEffect } from 'react';\nimport { useReducedMotion } from '../use-reduced-motion/use-reduced-motion.mjs';\nimport { useWindowEvent } from '../use-window-event/use-window-event.mjs';\nfunction useScrollIntoView({\n  duration = 1250,\n  axis = \"y\",\n  onScrollFinish,\n  easing = easeInOutQuad,\n  offset = 0,\n  cancelable = true,\n  isList = false\n} = {}) {\n  const frameID = useRef(0);\n  const startTime = useRef(0);\n  const shouldStop = useRef(false);\n  const scrollableRef = useRef(null);\n  const targetRef = useRef(null);\n  const reducedMotion = useReducedMotion();\n  const cancel = () => {\n    if (frameID.current) {\n      cancelAnimationFrame(frameID.current);\n    }\n  };\n  const scrollIntoView = useCallback(({\n    alignment = \"start\"\n  } = {}) => {\n    shouldStop.current = false;\n    if (frameID.current) {\n      cancel();\n    }\n    const start = getScrollStart({\n      parent: scrollableRef.current,\n      axis\n    }) ?? 0;\n    const change = getRelativePosition({\n      parent: scrollableRef.current,\n      target: targetRef.current,\n      axis,\n      alignment,\n      offset,\n      isList\n    }) - (scrollableRef.current ? 0 : start);\n    function animateScroll() {\n      if (startTime.current === 0) {\n        startTime.current = performance.now();\n      }\n      const now = performance.now();\n      const elapsed = now - startTime.current;\n      const t = reducedMotion || duration === 0 ? 1 : elapsed / duration;\n      const distance = start + change * easing(t);\n      setScrollParam({\n        parent: scrollableRef.current,\n        axis,\n        distance\n      });\n      if (!shouldStop.current && t < 1) {\n        frameID.current = requestAnimationFrame(animateScroll);\n      } else {\n        typeof onScrollFinish === \"function\" && onScrollFinish();\n        startTime.current = 0;\n        frameID.current = 0;\n        cancel();\n      }\n    }\n    animateScroll();\n  }, [axis, duration, easing, isList, offset, onScrollFinish, reducedMotion]);\n  const handleStop = () => {\n    if (cancelable) {\n      shouldStop.current = true;\n    }\n  };\n  useWindowEvent(\"wheel\", handleStop, {\n    passive: true\n  });\n  useWindowEvent(\"touchmove\", handleStop, {\n    passive: true\n  });\n  useEffect(() => cancel, []);\n  return {\n    scrollableRef,\n    targetRef,\n    scrollIntoView,\n    cancel\n  };\n}\nfunction easeInOutQuad(t) {\n  return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n}\nfunction getRelativePosition({\n  axis,\n  target,\n  parent,\n  alignment,\n  offset,\n  isList\n}) {\n  if (!target || !parent && typeof document === \"undefined\") {\n    return 0;\n  }\n  const isCustomParent = !!parent;\n  const parentElement = parent || document.body;\n  const parentPosition = parentElement.getBoundingClientRect();\n  const targetPosition = target.getBoundingClientRect();\n  const getDiff = property => targetPosition[property] - parentPosition[property];\n  if (axis === \"y\") {\n    const diff = getDiff(\"top\");\n    if (diff === 0) {\n      return 0;\n    }\n    if (alignment === \"start\") {\n      const distance = diff - offset;\n      const shouldScroll = distance <= targetPosition.height * (isList ? 0 : 1) || !isList;\n      return shouldScroll ? distance : 0;\n    }\n    const parentHeight = isCustomParent ? parentPosition.height : window.innerHeight;\n    if (alignment === \"end\") {\n      const distance = diff + offset - parentHeight + targetPosition.height;\n      const shouldScroll = distance >= -targetPosition.height * (isList ? 0 : 1) || !isList;\n      return shouldScroll ? distance : 0;\n    }\n    if (alignment === \"center\") {\n      return diff - parentHeight / 2 + targetPosition.height / 2;\n    }\n    return 0;\n  }\n  if (axis === \"x\") {\n    const diff = getDiff(\"left\");\n    if (diff === 0) {\n      return 0;\n    }\n    if (alignment === \"start\") {\n      const distance = diff - offset;\n      const shouldScroll = distance <= targetPosition.width || !isList;\n      return shouldScroll ? distance : 0;\n    }\n    const parentWidth = isCustomParent ? parentPosition.width : window.innerWidth;\n    if (alignment === \"end\") {\n      const distance = diff + offset - parentWidth + targetPosition.width;\n      const shouldScroll = distance >= -targetPosition.width || !isList;\n      return shouldScroll ? distance : 0;\n    }\n    if (alignment === \"center\") {\n      return diff - parentWidth / 2 + targetPosition.width / 2;\n    }\n    return 0;\n  }\n  return 0;\n}\nfunction getScrollStart({\n  axis,\n  parent\n}) {\n  if (!parent && typeof document === \"undefined\") {\n    return 0;\n  }\n  const method = axis === \"y\" ? \"scrollTop\" : \"scrollLeft\";\n  if (parent) {\n    return parent[method];\n  }\n  const {\n    body,\n    documentElement\n  } = document;\n  return body[method] + documentElement[method];\n}\nfunction setScrollParam({\n  axis,\n  parent,\n  distance\n}) {\n  if (!parent && typeof document === \"undefined\") {\n    return;\n  }\n  const method = axis === \"y\" ? \"scrollTop\" : \"scrollLeft\";\n  if (parent) {\n    parent[method] = distance;\n  } else {\n    const {\n      body,\n      documentElement\n    } = document;\n    body[method] = distance;\n    documentElement[method] = distance;\n  }\n}\nexport { useScrollIntoView };","map":{"version":3,"names":["useScrollIntoView","duration","axis","onScrollFinish","easing","easeInOutQuad","offset","cancelable","isList","frameID","useRef","startTime","shouldStop","scrollableRef","targetRef","reducedMotion","useReducedMotion","cancel","current","cancelAnimationFrame","scrollIntoView","useCallback","alignment","start","getScrollStart","parent","change","getRelativePosition","target","animateScroll","performance","now","elapsed","t","distance","setScrollParam","requestAnimationFrame","handleStop","useWindowEvent","passive","useEffect","document","isCustomParent","parentElement","body","parentPosition","getBoundingClientRect","targetPosition","getDiff","property","diff","shouldScroll","height","parentHeight","window","innerHeight","width","parentWidth","innerWidth","method","documentElement"],"sources":["C:\\IVOSIS\\IvosisProjectManagement\\frontend\\node_modules\\@mantine\\hooks\\src\\use-scroll-into-view\\use-scroll-into-view.ts"],"sourcesContent":["import { useCallback, useEffect, useRef } from 'react';\nimport { useReducedMotion } from '../use-reduced-motion/use-reduced-motion';\nimport { useWindowEvent } from '../use-window-event/use-window-event';\n\ninterface UseScrollIntoViewAnimation {\n  /** Target element alignment relatively to parent based on current axis */\n  alignment?: 'start' | 'end' | 'center';\n}\n\nexport interface UseScrollIntoViewOptions {\n  /** Callback fired after scroll */\n  onScrollFinish?: () => void;\n\n  /** Duration of scroll in milliseconds */\n  duration?: number;\n\n  /** Axis of scroll */\n  axis?: 'x' | 'y';\n\n  /** Custom mathematical easing function */\n  easing?: (t: number) => number;\n\n  /** Additional distance between nearest edge and element */\n  offset?: number;\n\n  /** Indicator if animation may be interrupted by user scrolling */\n  cancelable?: boolean;\n\n  /** Prevents content jumping in scrolling lists with multiple targets */\n  isList?: boolean;\n}\n\nexport interface UseScrollIntoViewReturnValue<\n  Target extends HTMLElement = any,\n  Parent extends HTMLElement | null = null,\n> {\n  scrollableRef: React.RefObject<Parent | null>;\n  targetRef: React.RefObject<Target | null>;\n  scrollIntoView: (params?: UseScrollIntoViewAnimation) => void;\n  cancel: () => void;\n}\n\nexport function useScrollIntoView<\n  Target extends HTMLElement = any,\n  Parent extends HTMLElement | null = null,\n>({\n  duration = 1250,\n  axis = 'y',\n  onScrollFinish,\n  easing = easeInOutQuad,\n  offset = 0,\n  cancelable = true,\n  isList = false,\n}: UseScrollIntoViewOptions = {}): UseScrollIntoViewReturnValue<Target, Parent> {\n  const frameID = useRef(0);\n  const startTime = useRef(0);\n  const shouldStop = useRef(false);\n\n  const scrollableRef = useRef<Parent | null>(null);\n  const targetRef = useRef<Target | null>(null);\n\n  const reducedMotion = useReducedMotion();\n\n  const cancel = (): void => {\n    if (frameID.current) {\n      cancelAnimationFrame(frameID.current);\n    }\n  };\n\n  const scrollIntoView = useCallback(\n    ({ alignment = 'start' }: UseScrollIntoViewAnimation = {}) => {\n      shouldStop.current = false;\n\n      if (frameID.current) {\n        cancel();\n      }\n\n      const start = getScrollStart({ parent: scrollableRef.current, axis }) ?? 0;\n\n      const change =\n        getRelativePosition({\n          parent: scrollableRef.current,\n          target: targetRef.current,\n          axis,\n          alignment,\n          offset,\n          isList,\n        }) - (scrollableRef.current ? 0 : start);\n\n      function animateScroll() {\n        if (startTime.current === 0) {\n          startTime.current = performance.now();\n        }\n\n        const now = performance.now();\n        const elapsed = now - startTime.current;\n\n        // Easing timing progress\n        const t = reducedMotion || duration === 0 ? 1 : elapsed / duration;\n\n        const distance = start + change * easing(t);\n\n        setScrollParam({\n          parent: scrollableRef.current,\n          axis,\n          distance,\n        });\n\n        if (!shouldStop.current && t < 1) {\n          frameID.current = requestAnimationFrame(animateScroll);\n        } else {\n          typeof onScrollFinish === 'function' && onScrollFinish();\n          startTime.current = 0;\n          frameID.current = 0;\n          cancel();\n        }\n      }\n      animateScroll();\n    },\n    [axis, duration, easing, isList, offset, onScrollFinish, reducedMotion]\n  );\n\n  const handleStop = () => {\n    if (cancelable) {\n      shouldStop.current = true;\n    }\n  };\n\n  /**\n   * Detection of one of these events stops scroll animation\n   * wheel - mouse wheel / touch pad\n   * touchmove - any touchable device\n   */\n\n  useWindowEvent('wheel', handleStop, {\n    passive: true,\n  });\n\n  useWindowEvent('touchmove', handleStop, {\n    passive: true,\n  });\n\n  // Cleanup requestAnimationFrame\n  useEffect(() => cancel, []);\n\n  return {\n    scrollableRef,\n    targetRef,\n    scrollIntoView,\n    cancel,\n  };\n}\n\n// ---------------------------------------------------\n// Helpers\n// ---------------------------------------------------\n\nfunction easeInOutQuad(t: number) {\n  return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n}\n\nfunction getRelativePosition({ axis, target, parent, alignment, offset, isList }: any): number {\n  if (!target || (!parent && typeof document === 'undefined')) {\n    return 0;\n  }\n  const isCustomParent = !!parent;\n  const parentElement = parent || document.body;\n  const parentPosition = parentElement.getBoundingClientRect();\n  const targetPosition = target.getBoundingClientRect();\n\n  const getDiff = (property: 'top' | 'left'): number =>\n    targetPosition[property] - parentPosition[property];\n\n  if (axis === 'y') {\n    const diff = getDiff('top');\n\n    if (diff === 0) {\n      return 0;\n    }\n\n    if (alignment === 'start') {\n      const distance = diff - offset;\n      const shouldScroll = distance <= targetPosition.height * (isList ? 0 : 1) || !isList;\n\n      return shouldScroll ? distance : 0;\n    }\n\n    const parentHeight = isCustomParent ? parentPosition.height : window.innerHeight;\n\n    if (alignment === 'end') {\n      const distance = diff + offset - parentHeight + targetPosition.height;\n      const shouldScroll = distance >= -targetPosition.height * (isList ? 0 : 1) || !isList;\n\n      return shouldScroll ? distance : 0;\n    }\n\n    if (alignment === 'center') {\n      return diff - parentHeight / 2 + targetPosition.height / 2;\n    }\n\n    return 0;\n  }\n\n  if (axis === 'x') {\n    const diff = getDiff('left');\n\n    if (diff === 0) {\n      return 0;\n    }\n\n    if (alignment === 'start') {\n      const distance = diff - offset;\n      const shouldScroll = distance <= targetPosition.width || !isList;\n\n      return shouldScroll ? distance : 0;\n    }\n\n    const parentWidth = isCustomParent ? parentPosition.width : window.innerWidth;\n\n    if (alignment === 'end') {\n      const distance = diff + offset - parentWidth + targetPosition.width;\n      const shouldScroll = distance >= -targetPosition.width || !isList;\n\n      return shouldScroll ? distance : 0;\n    }\n\n    if (alignment === 'center') {\n      return diff - parentWidth / 2 + targetPosition.width / 2;\n    }\n\n    return 0;\n  }\n\n  return 0;\n}\n\nfunction getScrollStart({ axis, parent }: any) {\n  if (!parent && typeof document === 'undefined') {\n    return 0;\n  }\n\n  const method = axis === 'y' ? 'scrollTop' : 'scrollLeft';\n\n  if (parent) {\n    return parent[method];\n  }\n\n  const { body, documentElement } = document;\n\n  // While one of it has a value the second is equal 0\n  return body[method] + documentElement[method];\n}\n\nfunction setScrollParam({ axis, parent, distance }: any) {\n  if (!parent && typeof document === 'undefined') {\n    return;\n  }\n\n  const method = axis === 'y' ? 'scrollTop' : 'scrollLeft';\n\n  if (parent) {\n    parent[method] = distance;\n  } else {\n    const { body, documentElement } = document;\n    body[method] = distance;\n    documentElement[method] = distance;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}