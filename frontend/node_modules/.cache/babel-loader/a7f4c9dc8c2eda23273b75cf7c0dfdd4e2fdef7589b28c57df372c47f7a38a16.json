{"ast":null,"code":"'use client';\n\nimport { useState } from 'react';\nfunction useQueue({\n  initialValues = [],\n  limit\n}) {\n  const [state, setState] = useState({\n    state: initialValues.slice(0, limit),\n    queue: initialValues.slice(limit)\n  });\n  const add = (...items) => setState(current => {\n    const results = [...current.state, ...current.queue, ...items];\n    return {\n      state: results.slice(0, limit),\n      queue: results.slice(limit)\n    };\n  });\n  const update = fn => setState(current => {\n    const results = fn([...current.state, ...current.queue]);\n    return {\n      state: results.slice(0, limit),\n      queue: results.slice(limit)\n    };\n  });\n  const cleanQueue = () => setState(current => ({\n    state: current.state,\n    queue: []\n  }));\n  return {\n    state: state.state,\n    queue: state.queue,\n    add,\n    update,\n    cleanQueue\n  };\n}\nexport { useQueue };","map":{"version":3,"names":["useQueue","initialValues","limit","state","setState","useState","slice","queue","add","items","current","results","update","fn","cleanQueue"],"sources":["C:\\IVOSIS\\IvosisProjectManagement\\frontend\\node_modules\\@mantine\\hooks\\src\\use-queue\\use-queue.ts"],"sourcesContent":["import { useState } from 'react';\n\nexport interface UseQueueOptions<T> {\n  /** Initial values to be added to the queue */\n  initialValues?: T[];\n\n  /** Maximum number of items in the state */\n  limit: number;\n}\n\nexport interface UseQueueReturnValue<T> {\n  /** Array of items in the queue */\n  queue: T[];\n\n  /** Array of items in the state */\n  state: T[];\n\n  /** Function to add items to state or queue */\n  add: (...items: T[]) => void;\n\n  /** Function to apply updates to current items */\n  update: (fn: (state: T[]) => T[]) => void;\n\n  /** Function to clear the queue */\n  cleanQueue: () => void;\n}\n\nexport function useQueue<T>({\n  initialValues = [],\n  limit,\n}: UseQueueOptions<T>): UseQueueReturnValue<T> {\n  const [state, setState] = useState({\n    state: initialValues.slice(0, limit),\n    queue: initialValues.slice(limit),\n  });\n\n  const add = (...items: T[]) =>\n    setState((current) => {\n      const results = [...current.state, ...current.queue, ...items];\n\n      return {\n        state: results.slice(0, limit),\n        queue: results.slice(limit),\n      };\n    });\n\n  const update = (fn: (state: T[]) => T[]) =>\n    setState((current) => {\n      const results = fn([...current.state, ...current.queue]);\n\n      return {\n        state: results.slice(0, limit),\n        queue: results.slice(limit),\n      };\n    });\n\n  const cleanQueue = () => setState((current) => ({ state: current.state, queue: [] }));\n\n  return {\n    state: state.state,\n    queue: state.queue,\n    add,\n    update,\n    cleanQueue,\n  };\n}\n"],"mappings":";;;AA2BO,SAASA,QAAYA,CAAA;EAC1BC,aAAA,GAAgB,EAAC;EACjBC;AACF,CAA+C;EAC7C,MAAM,CAACC,KAAA,EAAOC,QAAQ,IAAIC,QAAS;IACjCF,KAAO,EAAAF,aAAA,CAAcK,KAAM,IAAGJ,KAAK;IACnCK,KAAA,EAAON,aAAc,CAAAK,KAAA,CAAMJ,KAAK;EAAA,CACjC;EAED,MAAMM,GAAM,GAAAA,CAAA,GAAIC,KACd,KAAAL,QAAA,CAAUM,OAAY;IACd,MAAAC,OAAA,GAAU,CAAC,GAAGD,OAAA,CAAQP,KAAA,EAAO,GAAGO,OAAA,CAAQH,KAAO,KAAGE,KAAK;IAEtD;MACLN,KAAO,EAAAQ,OAAA,CAAQL,KAAM,IAAGJ,KAAK;MAC7BK,KAAA,EAAOI,OAAQ,CAAAL,KAAA,CAAMJ,KAAK;IAC5B;EAAA,CACD;EAEH,MAAMU,MAAS,GAACC,EACd,IAAAT,QAAA,CAAUM,OAAY;IACd,MAAAC,OAAA,GAAUE,EAAA,CAAG,CAAC,GAAGH,OAAA,CAAQP,KAAO,KAAGO,OAAQ,CAAAH,KAAK,CAAC;IAEhD;MACLJ,KAAO,EAAAQ,OAAA,CAAQL,KAAM,IAAGJ,KAAK;MAC7BK,KAAA,EAAOI,OAAQ,CAAAL,KAAA,CAAMJ,KAAK;IAC5B;EAAA,CACD;EAEH,MAAMY,UAAa,GAAAA,CAAA,KAAMV,QAAS,CAACM,OAAa;IAAEP,KAAO,EAAAO,OAAA,CAAQP,KAAO;IAAAI,KAAA,EAAO;EAAK;EAE7E;IACLJ,KAAA,EAAOA,KAAM,CAAAA,KAAA;IACbI,KAAA,EAAOJ,KAAM,CAAAI,KAAA;IACbC,GAAA;IACAI,MAAA;IACAE;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}